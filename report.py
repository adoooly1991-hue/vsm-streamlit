# report.py
from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.dml.color import RGBColor
from pptx.enum.shapes import MSO_SHAPE
from pptx.enum.text import PP_ALIGN
from reportlab.lib.pagesizes import A4, landscape
from reportlab.pdfgen import canvas
from reportlab.lib.units import cm

SEV_COLORS = {
    "high": RGBColor(255, 199, 206),   # Red-ish
    "med":  RGBColor(255, 235, 156),   # Amber
    "low":  RGBColor(198, 239, 206),   # Green
}

WASTE_ICON = {
    "defects": "D",
    "waiting": "W",
    "inventory": "I",
    "overproduction": "OP",
    "transportation": "T",
    "motion": "M",
    "overprocessing": "O",
    "talent": "UT"
}

def export_observations_pptx(observations_df, out_path, steps=None, perstep_top2=None, spacing_mode="Effective CT", ct_eff_map=None):
    prs = Presentation()
    title = prs.slides.add_slide(prs.slide_layouts[0])
    title.shapes.title.text = "Automated VSM – Observations & Map"
    title.placeholders[1].text = "Generated by VSM Observation Engine"

    # Current State Map (if provided)
    if steps and perstep_top2:
        add_current_state_map_slide(prs, steps, perstep_top2, spacing_mode=spacing_mode, ct_eff_map=ct_eff_map or {})

    # Summary
    slide = prs.slides.add_slide(prs.slide_layouts[5])
    tx = slide.shapes.add_textbox(Inches(0.5), Inches(0.3), Inches(9), Inches(1))
    tf = tx.text_frame; tf.text = "Summary (Top Observations)"
    tf.paragraphs[0].font.size = Pt(28)
    y = 1.2
    for i, row in observations_df.head(8).iterrows():
        tb = slide.shapes.add_textbox(Inches(0.5), Inches(y), Inches(9), Inches(0.6))
        p = tb.text_frame.paragraphs[0]
        p.text = f"{row['step_name']} — {row['waste'].title()} | Score {row['score_0_5']:.1f} | RPN {row['rpn_pct']:.0f}% | {row['confidence']}"
        p.font.size = Pt(14)
        y += 0.6

    # Detail slides
    for _, row in observations_df.iterrows():
        s = prs.slides.add_slide(prs.slide_layouts[5])
        header = s.shapes.add_textbox(Inches(0.5), Inches(0.3), Inches(9), Inches(0.8))
        header.text_frame.text = f"{row['step_name']} — {row['waste'].title()}"
        header.text_frame.paragraphs[0].font.size = Pt(26)
        meta = s.shapes.add_textbox(Inches(0.5), Inches(1.2), Inches(9), Inches(0.6))
        meta.text_frame.text = f"Score {row['score_0_5']:.1f} | RPN {row['rpn_pct']:.0f}% | Confidence: {row['confidence']}"
        meta.text_frame.paragraphs[0].font.size = Pt(14)
        body = s.shapes.add_textbox(Inches(0.5), Inches(2.0), Inches(9), Inches(3))
        body.text_frame.text = row['observation']
        body.text_frame.paragraphs[0].font.size = Pt(18)

    prs.save(out_path)
    return out_path

def add_current_state_map_slide(prs, steps, perstep_top2, spacing_mode="Effective CT", ct_eff_map=None):
    slide = prs.slides.add_slide(prs.slide_layouts[5])

    # Title
    title = slide.shapes.add_textbox(Inches(0.5), Inches(0.2), Inches(9), Inches(0.5))
    title_tf = title.text_frame
    title_tf.text = "Current State Map"
    title_tf.paragraphs[0].font.size = Pt(28)

    # Lanes
    info_y = Inches(0.9)
    mat_y = Inches(5.2)
    info_lane = slide.shapes.add_shape(MSO_SHAPE.RECTANGLE, Inches(0.3), info_y, Inches(9.2), Inches(0.5))
    info_lane.text_frame.text = "Information Flow"
    mat_lane = slide.shapes.add_shape(MSO_SHAPE.RECTANGLE, Inches(0.3), mat_y, Inches(9.2), Inches(0.5))
    mat_lane.text_frame.text = "Material Flow"

    # Determine spacing values
    # Default uniform gap of 3.0 inches, scaled by metric (Effective CT sec or WIP units)
    metrics = []
    for s in steps:
        if spacing_mode == "WIP":
            metrics.append(max(1.0, float(s.wip_units_in or 1.0)))
        else:
            metrics.append(max(1.0, float(ct_eff_map.get(s.id, s.ct_sec or 1.0))))
    # Normalize to a mean of ~1.0
    avg = sum(metrics)/len(metrics) if metrics else 1.0
    scales = [m/avg for m in metrics]

    # Process boxes with heatmap colors and badges
    start_x = Inches(0.5); box_w = Inches(2.6); box_h = Inches(2.4)
    box_y = Inches(2.0)
    positions = []
    x = start_x
    for i, s in enumerate(steps):
        # Determine severity color by highest waste score among top2 (fallback to low)
        top2 = perstep_top2.get(s.id, [])
        max_score = max([sc for _, sc in top2], default=0.0)
        sev = "high" if max_score >= 4.0 else ("med" if max_score >= 2.5 else "low")
        fill_color = SEV_COLORS[sev]

        rect = slide.shapes.add_shape(MSO_SHAPE.ROUNDED_RECTANGLE, x, box_y, box_w, box_h)
        rect.fill.solid(); rect.fill.fore_color.rgb = fill_color
        rect.line.color.rgb = RGBColor(91, 155, 213)

        tf = rect.text_frame; tf.clear()
        p = tf.paragraphs[0]; p.text = f"{s.id} – {s.name}"; p.font.size = Pt(14); p.font.bold = True
        body = [
            f"CT: {int((s.ct_sec or 0))} s",
            f"WIP: {int((s.wip_units_in or 0))}",
            f"Defects: {s.defect_pct or 0:.1f}%",
            f"Mode: {s.push_pull or ''}"
        ]
        for line in body:
            q = tf.add_paragraph(); q.text = line; q.level = 1; q.font.size = Pt(11)

        # Top-2 waste chips with icon + score
        chip_x = x + Inches(0.1); chip_y = box_y - Inches(0.35)
        for idx, (wname, wscore) in enumerate(top2[:2]):
            chip = slide.shapes.add_shape(MSO_SHAPE.ROUNDED_RECTANGLE, chip_x + Inches(idx*1.2), chip_y, Inches(1.1), Inches(0.3))
            chip.line.color.rgb = RGBColor(120,120,120)
            # chip color by its own severity
            chip_sev = "high" if wscore >= 4.0 else ("med" if wscore >= 2.5 else "low")
            chip.fill.solid(); chip.fill.fore_color.rgb = SEV_COLORS[chip_sev]
            ch_tf = chip.text_frame; ch_tf.clear()
            ch_tf.text = f"{WASTE_ICON.get(wname,wname[:2].upper())} {wscore:.1f}"
            ch_tf.paragraphs[0].font.size = Pt(10); ch_tf.paragraphs[0].alignment = PP_ALIGN.CENTER

        positions.append((x, box_y))
        # advance x by scaled gap
        gap = Inches(2.4) * scales[i]
        x = x + box_w + gap

    # Material flow arrows (Push solid; Pull arrow + Kanban icon)
    for i in range(len(positions)-1):
        (x1, y1) = positions[i]; (x2, y2) = positions[i+1]
        conn = slide.shapes.add_connector(1, int(x1+box_w), int(y1+box_h/2), int(x2), int(y2+box_h/2))
        conn.line.width = Pt(2); conn.line.color.rgb = RGBColor(0,0,0)
        is_pull = (steps[i].push_pull or "").lower() == "pull"
        if is_pull:
            # Draw a small Kanban "cards" icon near the mid-point
            midx = int((x1 + x2)/2)
            kan = slide.shapes.add_shape(MSO_SHAPE.RECTANGLE, midx, int(y1+box_h/2 - Inches(0.22)), Inches(0.6), Inches(0.28))
            kan.fill.solid(); kan.fill.fore_color.rgb = RGBColor(255,255,255)
            kan.line.color.rgb = RGBColor(0,0,0)
            k_tf = kan.text_frame; k_tf.text = "KANBAN"
            k_tf.paragraphs[0].font.size = Pt(9); k_tf.paragraphs[0].alignment = PP_ALIGN.CENTER

    # Information flow (solid for Auto/Semi-auto; dashed-like simulated via tiny gaps for Manual)
    from pptx.oxml.xmlchemy import OxmlElement
    def set_dashed(line_format):
        # Simulate dashed by setting dash style (python-pptx supports line.dash_style)
        try:
            line_format.dash_style = 3  # MSO_LINE_DASH_STYLE.DASH (enum may vary across versions)
        except Exception:
            pass

    src = slide.shapes.add_shape(MSO_SHAPE.FOLDED_CORNER, Inches(0.5), info_y+Inches(0.6), Inches(1.0), Inches(0.7))
    src.text_frame.text = "ERP/MRP"
    for (x, y), s in zip(positions, steps):
        lc = slide.shapes.add_connector(1, int(Inches(1.5)), int(info_y+Inches(1.0)), int(x+box_w/2), int(y))
        lc.line.color.rgb = RGBColor(0,0,0)
        lc.line.width = Pt(1.5)
        if (s.process_type or "Manual") == "Manual":
            set_dashed(lc.line)

    # Legend box
    add_legend(slide, Inches(7.6), Inches(0.6))

def add_legend(slide, x, y):
    box = slide.shapes.add_shape(MSO_SHAPE.ROUNDED_RECTANGLE, x, y, Inches(2.2), Inches(3.6))
    box.fill.solid(); box.fill.fore_color.rgb = RGBColor(245,245,245)
    box.line.color.rgb = RGBColor(120,120,120)
    tf = box.text_frame; tf.clear()
    p = tf.paragraphs[0]; p.text = "Legend"; p.font.size = Pt(14); p.font.bold = True

    # Flow lines
    items = [
        ("Flow Lines", ""),
        ("Solid Arrow", "Push flow"),
        ("Hollow + Kanban", "Pull flow"),
        ("Dashed line", "Manual info flow"),
        ("Solid line", "Digital info flow"),
        ("", ""),
        ("Box Colors", ""),
        ("Red", "High severity (≥4.0)"),
        ("Amber", "Medium (2.5–3.9)"),
        ("Green", "Low (<2.5)"),
        ("", ""),
        ("Waste Badges", ""),
        ("D/W/I/OP/T/M/O/UT", "Waste code + score"),
    ]
    for title, desc in items:
        p = tf.add_paragraph()
        p.text = f"{title}: {desc}" if desc else title
        p.font.size = Pt(10)

def export_observations_pdf(observations_df, out_path):
    c = canvas.Canvas(out_path, pagesize=landscape(A4))
    w, h = landscape(A4)
    c.setFont("Helvetica-Bold", 20)
    c.drawString(2*cm, h-1.5*cm, "Automated VSM – Observations")

    c.setFont("Helvetica-Bold", 12)
    y = h-3.0*cm
    for _, row in observations_df.iterrows():
        c.drawString(1.5*cm, y, f"{row['step_name']} — {row['waste'].title()} (Score {row['score_0_5']:.1f} | RPN {row['rpn_pct']:.0f}% | {row['confidence']})")
        y -= 0.7*cm
        c.setFont("Helvetica", 11)
        for line in split_text(row['observation'], max_chars=140):
            c.drawString(2.0*cm, y, line); y -= 0.55*cm
            if y < 2.0*cm:
                c.showPage(); y = h-2.0*cm; c.setFont("Helvetica", 11)
        c.setFont("Helvetica-Bold", 12)
        y -= 0.3*cm
        if y < 3.0*cm:
            c.showPage(); y = h-3.0*cm; c.setFont("Helvetica-Bold", 12)
    c.showPage(); c.save()
    return out_path

def split_text(text, max_chars=100):
    words = text.split()
    out, cur = [], ""
    for w in words:
        if len(cur)+len(w)+1 <= max_chars:
            cur = (cur+" "+w).strip()
        else:
            out.append(cur); cur = w
    if cur: out.append(cur)
    return out
